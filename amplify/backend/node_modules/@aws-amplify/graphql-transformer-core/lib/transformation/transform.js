"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLTransform = void 0;
const aws_appsync_1 = require("@aws-cdk/aws-appsync");
const core_1 = require("@aws-cdk/core");
const amplify_prompts_1 = require("amplify-prompts");
const fs = __importStar(require("fs-extra"));
const graphql_1 = require("graphql");
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const path = __importStar(require("path"));
const vm = __importStar(require("vm2"));
const errors_1 = require("../errors");
const graphql_api_1 = require("../graphql-api");
const transformer_context_1 = require("../transformer-context");
const utils_1 = require("../types/utils");
const authType_1 = require("../utils/authType");
const SyncUtils = __importStar(require("./sync-utils"));
const cdk_compat_1 = require("../cdk-compat");
const utils_2 = require("./utils");
const validation_1 = require("./validation");
const pre_process_context_1 = require("../transformer-context/pre-process-context");
function isFunction(obj) {
    return obj && typeof obj === 'function';
}
class GraphQLTransform {
    constructor(options) {
        this.options = options;
        this.seenTransformations = {};
        this.applyOverride = (stackManager) => {
            const stacks = [];
            const amplifyApiObj = {};
            stackManager.rootStack.node.findAll().forEach(node => {
                const resource = node;
                if (resource.cfnResourceType === 'AWS::CloudFormation::Stack') {
                    stacks.push(node.node.id.split('.')[0]);
                }
            });
            stackManager.rootStack.node.findAll().forEach(node => {
                const resource = node;
                let pathArr;
                if (node.node.id === 'Resource') {
                    pathArr = node.node.path.split('/').filter(key => key !== node.node.id);
                }
                else {
                    pathArr = node.node.path.split('/');
                }
                let constructPathObj;
                if (resource.cfnResourceType) {
                    constructPathObj = (0, utils_1.getStackMeta)(pathArr, node.node.id, stacks, resource);
                    if (!lodash_1.default.isEmpty(constructPathObj.rootStack)) {
                        const field = constructPathObj.rootStack.stackType;
                        const { resourceName } = constructPathObj;
                        lodash_1.default.set(amplifyApiObj, [field, resourceName], resource);
                    }
                    else if (!lodash_1.default.isEmpty(constructPathObj.nestedStack)) {
                        const fieldType = constructPathObj.nestedStack.stackType;
                        const fieldName = constructPathObj.nestedStack.stackName;
                        const { resourceName } = constructPathObj;
                        if (constructPathObj.resourceType.includes('Resolver')) {
                            lodash_1.default.set(amplifyApiObj, [fieldType, fieldName, 'resolvers', resourceName], resource);
                        }
                        else if (constructPathObj.resourceType.includes('FunctionConfiguration')) {
                            lodash_1.default.set(amplifyApiObj, [fieldType, fieldName, 'appsyncFunctions', resourceName], resource);
                        }
                        else {
                            lodash_1.default.set(amplifyApiObj, [fieldType, fieldName, resourceName], resource);
                        }
                    }
                }
            });
            const appsyncResourceObj = (0, utils_1.convertToAppsyncResourceObj)(amplifyApiObj);
            if (!lodash_1.default.isEmpty(this.overrideConfig) && this.overrideConfig.overrideFlag) {
                const overrideCode = fs.readFileSync(path.join(this.overrideConfig.overrideDir, 'build', 'override.js'), 'utf-8');
                const sandboxNode = new vm.NodeVM({
                    console: 'inherit',
                    timeout: 5000,
                    sandbox: {},
                    require: {
                        context: 'sandbox',
                        builtin: ['path'],
                        external: true,
                    },
                });
                try {
                    sandboxNode.run(overrideCode, path.join(this.overrideConfig.overrideDir, 'build', 'override.js')).override(appsyncResourceObj);
                }
                catch (err) {
                    const error = new Error(`Skipping override due to ${err}${os_1.default.EOL}`);
                    amplify_prompts_1.printer.error(`${error}`);
                    error.stack = undefined;
                    throw error;
                }
            }
            return appsyncResourceObj;
        };
        if (!options.transformers || options.transformers.length === 0) {
            throw new Error('Must provide at least one transformer.');
        }
        const sortedTransformers = (0, utils_2.sortTransformerPlugins)(options.transformers);
        this.transformers = sortedTransformers;
        this.authConfig = options.authConfig || {
            defaultAuthentication: {
                authenticationType: 'API_KEY',
                apiKeyConfig: {
                    apiKeyExpirationDays: 7,
                    description: 'Default API Key',
                },
            },
            additionalAuthenticationProviders: [],
        };
        (0, validation_1.validateAuthModes)(this.authConfig);
        this.buildParameters = options.buildParameters || {};
        this.stackMappingOverrides = options.stackMapping || {};
        this.transformConfig = options.transformConfig || {};
        this.userDefinedSlots = options.userDefinedSlots || {};
        this.resolverConfig = options.resolverConfig || {};
        this.overrideConfig = options.overrideConfig;
    }
    preProcessSchema(schema) {
        var _a;
        const context = new pre_process_context_1.TransformerPreProcessContext(schema, (_a = this === null || this === void 0 ? void 0 : this.options) === null || _a === void 0 ? void 0 : _a.featureFlags);
        this.transformers
            .filter(transformer => isFunction(transformer.preMutateSchema))
            .map(transformer => transformer.preMutateSchema)
            .forEach(preMutateSchema => preMutateSchema(context));
        return this.transformers
            .filter(transformer => isFunction(transformer.mutateSchema))
            .map(transformer => transformer.mutateSchema)
            .reduce((mutateContext, mutateSchema) => {
            const updatedSchema = mutateSchema(mutateContext);
            return {
                ...mutateContext,
                inputDocument: updatedSchema,
            };
        }, context).inputDocument;
    }
    transform(schema) {
        var _a;
        this.seenTransformations = {};
        const parsedDocument = (0, graphql_1.parse)(schema);
        this.app = new core_1.App();
        const context = new transformer_context_1.TransformerContext(this.app, parsedDocument, this.stackMappingOverrides, this.authConfig, this.options.sandboxModeEnabled, this.options.featureFlags, this.resolverConfig);
        const validDirectiveNameMap = this.transformers.reduce((acc, t) => ({ ...acc, [t.directive.name.value]: true }), {
            aws_subscribe: true,
            aws_auth: true,
            aws_api_key: true,
            aws_iam: true,
            aws_oidc: true,
            aws_lambda: true,
            aws_cognito_user_pools: true,
            deprecated: true,
        });
        let allModelDefinitions = [...context.inputDocument.definitions];
        for (const transformer of this.transformers) {
            allModelDefinitions = allModelDefinitions.concat(...transformer.typeDefinitions, transformer.directive);
        }
        const errors = (0, validation_1.validateModelSchema)({
            kind: graphql_1.Kind.DOCUMENT,
            definitions: allModelDefinitions,
        });
        if (errors && errors.length) {
            throw new errors_1.SchemaValidationError(errors);
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.before)) {
                transformer.before(context);
            }
        }
        for (const transformer of this.transformers) {
            for (const def of context.inputDocument.definitions) {
                switch (def.kind) {
                    case 'ObjectTypeDefinition':
                        this.transformObject(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'InterfaceTypeDefinition':
                        this.transformInterface(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'ScalarTypeDefinition':
                        this.transformScalar(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'UnionTypeDefinition':
                        this.transformUnion(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'EnumTypeDefinition':
                        this.transformEnum(transformer, def, validDirectiveNameMap, context);
                        break;
                    case 'InputObjectTypeDefinition':
                        this.transformInputObject(transformer, def, validDirectiveNameMap, context);
                        break;
                    default:
                        continue;
                }
            }
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.validate)) {
                transformer.validate(context);
            }
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.prepare)) {
                transformer.prepare(context);
            }
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.transformSchema)) {
                transformer.transformSchema(context);
            }
        }
        const stackManager = context.stackManager;
        const output = context.output;
        const api = this.generateGraphQlApi(stackManager, output);
        context.bind(api);
        if (!lodash_1.default.isEmpty(this.resolverConfig)) {
            SyncUtils.createSyncTable(context);
        }
        for (const transformer of this.transformers) {
            if (isFunction(transformer.generateResolvers)) {
                transformer.generateResolvers(context);
            }
        }
        let reverseThroughTransformers = this.transformers.length - 1;
        while (reverseThroughTransformers >= 0) {
            const transformer = this.transformers[reverseThroughTransformers];
            if (isFunction(transformer.after)) {
                transformer.after(context);
            }
            reverseThroughTransformers -= 1;
        }
        this.collectResolvers(context, context.api);
        if ((_a = this.overrideConfig) === null || _a === void 0 ? void 0 : _a.overrideFlag) {
            this.applyOverride(stackManager);
            return this.synthesize(context);
        }
        return this.synthesize(context);
    }
    generateGraphQlApi(stackManager, output) {
        var _a, _b;
        const { rootStack } = stackManager;
        const authorizationConfig = (0, authType_1.adoptAuthModes)(stackManager, this.authConfig);
        const apiName = stackManager.addParameter('AppSyncApiName', {
            default: 'AppSyncSimpleTransform',
            type: 'String',
        }).valueAsString;
        const envName = stackManager.getParameter('env');
        if (!envName) {
            throw new Error('Parameter `env` not configured properly.');
        }
        const api = new graphql_api_1.GraphQLApi(rootStack, 'GraphQLAPI', {
            name: `${apiName}-${envName.valueAsString}`,
            authorizationConfig,
            host: this.options.host,
            sandboxModeEnabled: this.options.sandboxModeEnabled,
            environmentName: envName.valueAsString,
        });
        const authModes = [authorizationConfig.defaultAuthorization, ...(authorizationConfig.additionalAuthorizationModes || [])].map(mode => mode === null || mode === void 0 ? void 0 : mode.authorizationType);
        const hasLegacyAPIKeyConfigDisabled = 'CreateAPIKey' in this.buildParameters && this.buildParameters.CreateAPIKey !== 1;
        if (authModes.includes(aws_appsync_1.AuthorizationType.API_KEY) && !hasLegacyAPIKeyConfigDisabled) {
            const apiKeyConfig = [
                authorizationConfig.defaultAuthorization,
                ...(authorizationConfig.additionalAuthorizationModes || []),
            ].find(auth => (auth === null || auth === void 0 ? void 0 : auth.authorizationType) == aws_appsync_1.AuthorizationType.API_KEY);
            const apiKeyDescription = (_a = apiKeyConfig.apiKeyConfig) === null || _a === void 0 ? void 0 : _a.description;
            const apiKeyExpirationDays = (_b = apiKeyConfig.apiKeyConfig) === null || _b === void 0 ? void 0 : _b.expires;
            const apiKey = api.createAPIKey({
                description: apiKeyDescription,
                expires: apiKeyExpirationDays,
            });
            new core_1.CfnOutput(rootStack, 'GraphQLAPIKeyOutput', {
                value: apiKey.attrApiKey,
                description: 'Your GraphQL API ID.',
                exportName: core_1.Fn.join(':', [core_1.Aws.STACK_NAME, 'GraphQLApiKey']),
            });
        }
        if (authModes.includes(aws_appsync_1.AuthorizationType.IAM)) {
            stackManager.addParameter(authType_1.IAM_AUTH_ROLE_PARAMETER, { type: 'String' });
            stackManager.addParameter(authType_1.IAM_UNAUTH_ROLE_PARAMETER, { type: 'String' });
        }
        new core_1.CfnOutput(rootStack, 'GraphQLAPIIdOutput', {
            value: api.apiId,
            description: 'Your GraphQL API ID.',
            exportName: core_1.Fn.join(':', [core_1.Aws.STACK_NAME, 'GraphQLApiId']),
        });
        new core_1.CfnOutput(rootStack, 'GraphQLAPIEndpointOutput', {
            value: api.graphqlUrl,
            description: 'Your GraphQL API endpoint.',
            exportName: core_1.Fn.join(':', [core_1.Aws.STACK_NAME, 'GraphQLApiEndpoint']),
        });
        api.addToSchema(output.buildSchema());
        return api;
    }
    synthesize(context) {
        var _a;
        const stackManager = context.stackManager;
        (_a = this.app) === null || _a === void 0 ? void 0 : _a.synth({ force: true, skipValidation: true });
        const templates = stackManager.getCloudFormationTemplates();
        const rootStackTemplate = templates.get('transformer-root-stack');
        const childStacks = {};
        for (const [templateName, template] of templates.entries()) {
            if (templateName !== 'transformer-root-stack') {
                childStacks[templateName] = template;
            }
        }
        const fileAssets = stackManager.getMappingTemplates();
        const pipelineFunctions = {};
        const resolvers = {};
        const functions = {};
        for (const [templateName, template] of fileAssets) {
            if (templateName.startsWith('pipelineFunctions/')) {
                pipelineFunctions[templateName.replace('pipelineFunctions/', '')] = template;
            }
            else if (templateName.startsWith('resolvers/')) {
                resolvers[templateName.replace('resolvers/', '')] = template;
            }
            else if (templateName.startsWith('functions/')) {
                functions[templateName.replace('functions/', '')] = template;
            }
        }
        const schema = fileAssets.get('schema.graphql') || '';
        const resolverEntries = context.resolvers.collectResolvers();
        const userOverriddenSlots = [];
        for (const [resolverName] of resolverEntries) {
            const userSlots = this.userDefinedSlots[resolverName] || [];
            userSlots.forEach(slot => {
                var _a;
                const fileName = (_a = slot.requestResolver) === null || _a === void 0 ? void 0 : _a.fileName;
                if (fileName && fileName in resolvers) {
                    userOverriddenSlots.push(fileName);
                }
            });
        }
        return {
            userOverriddenSlots,
            functions,
            pipelineFunctions,
            stackMapping: {},
            resolvers,
            schema,
            stacks: childStacks,
            rootStack: rootStackTemplate,
        };
    }
    collectResolvers(context, api) {
        const resolverEntries = context.resolvers.collectResolvers();
        const sortedResolverEntries = new Map([...resolverEntries].sort((a, b) => {
            const left = a[1].getStackName();
            const right = b[1].getStackName();
            if (left > right) {
                return 1;
            }
            if (left === right) {
                return 0;
            }
            return -1;
        }));
        for (const [resolverName, resolver] of sortedResolverEntries) {
            const userSlots = this.userDefinedSlots[resolverName] || [];
            userSlots.forEach(slot => {
                const requestTemplate = slot.requestResolver
                    ? cdk_compat_1.MappingTemplate.s3MappingTemplateFromString(slot.requestResolver.template, slot.requestResolver.fileName)
                    : undefined;
                const responseTemplate = slot.responseResolver
                    ? cdk_compat_1.MappingTemplate.s3MappingTemplateFromString(slot.responseResolver.template, slot.responseResolver.fileName)
                    : undefined;
                resolver.addToSlot(slot.slotName, requestTemplate, responseTemplate);
            });
            resolver.synthesize(context, api);
        }
    }
    transformObject(transformer, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.object)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.object(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'object()' method`);
                }
            }
            index++;
        }
        for (const field of (_b = def.fields) !== null && _b !== void 0 ? _b : []) {
            this.transformField(transformer, def, field, validDirectiveNameMap, context);
        }
    }
    transformField(transformer, parent, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchFieldDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.field)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, parent, def, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.field(parent, def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'field()' method`);
                }
            }
            index++;
        }
        for (const arg of (_b = def.arguments) !== null && _b !== void 0 ? _b : []) {
            this.transformArgument(transformer, parent, def, arg, validDirectiveNameMap, context);
        }
    }
    transformArgument(transformer, parent, field, arg, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = arg.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchArgumentDirective)(transformer.directive, dir, arg)) {
                if (isFunction(transformer.argument)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, parent, field, arg, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.argument(arg, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'argument()' method`);
                }
            }
            index++;
        }
    }
    transformInterface(transformer, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.interface)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.interface(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'interface()' method`);
                }
            }
            index++;
        }
        for (const field of (_b = def.fields) !== null && _b !== void 0 ? _b : []) {
            this.transformField(transformer, def, field, validDirectiveNameMap, context);
        }
    }
    transformScalar(transformer, def, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.scalar)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.scalar(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'scalar()' method`);
                }
            }
            index++;
        }
    }
    transformUnion(transformer, def, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.union)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.union(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'union()' method`);
                }
            }
            index++;
        }
    }
    transformEnum(transformer, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.enum)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.enum(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'enum()' method`);
                }
            }
            index++;
        }
        for (const value of (_b = def.values) !== null && _b !== void 0 ? _b : []) {
            this.transformEnumValue(transformer, def, value, validDirectiveNameMap, context);
        }
    }
    transformEnumValue(transformer, enm, def, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchEnumValueDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.enumValue)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, enm, def, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.enumValue(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'enumValue()' method`);
                }
            }
            index++;
        }
    }
    transformInputObject(transformer, def, validDirectiveNameMap, context) {
        var _a, _b;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.input)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, def, undefined, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.input(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'input()' method`);
                }
            }
            index++;
        }
        for (const field of (_b = def.fields) !== null && _b !== void 0 ? _b : []) {
            this.transformInputField(transformer, def, field, validDirectiveNameMap, context);
        }
    }
    transformInputField(transformer, input, def, validDirectiveNameMap, context) {
        var _a;
        let index = 0;
        for (const dir of (_a = def.directives) !== null && _a !== void 0 ? _a : []) {
            if (!validDirectiveNameMap[dir.name.value]) {
                throw new errors_1.UnknownDirectiveError(`Unknown directive '${dir.name.value}'. Either remove the directive from the schema or add a transformer to handle it.`);
            }
            if ((0, utils_2.matchInputFieldDirective)(transformer.directive, dir, def)) {
                if (isFunction(transformer.inputValue)) {
                    const transformKey = (0, utils_2.makeSeenTransformationKey)(dir, input, def, undefined, index);
                    if (!this.seenTransformations[transformKey]) {
                        transformer.inputValue(def, dir, context);
                        this.seenTransformations[transformKey] = true;
                    }
                }
                else {
                    throw new errors_1.InvalidTransformerError(`The transformer '${transformer.name}' must implement the 'inputValue()' method`);
                }
            }
            index++;
        }
    }
}
exports.GraphQLTransform = GraphQLTransform;
//# sourceMappingURL=transform.js.map