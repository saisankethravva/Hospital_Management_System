"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortTransformerPlugins = exports.matchEnumValueDirective = exports.matchArgumentDirective = exports.matchInputFieldDirective = exports.matchFieldDirective = exports.matchDirective = exports.makeSeenTransformationKey = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
function makeSeenTransformationKey(directive, type, field, arg, index) {
    let key = '';
    if (directive && type && field && arg) {
        key = `${type.name.value}.${field.name.value}.${arg.name.value}@${directive.name.value}`;
    }
    if (directive && type && field) {
        key = `${type.name.value}.${field.name.value}@${directive.name.value}`;
    }
    else {
        key = `${type.name.value}@${directive.name.value}`;
    }
    if (index !== undefined) {
        key += `[${index}]`;
    }
    return key;
}
exports.makeSeenTransformationKey = makeSeenTransformationKey;
function matchDirective(definition, directive, node) {
    if (!directive) {
        return false;
    }
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `SCHEMA`:
                isValidLocation = node.kind === graphql_1.Kind.SCHEMA_DEFINITION || isValidLocation;
                break;
            case `SCALAR`:
                isValidLocation = node.kind === graphql_1.Kind.SCALAR_TYPE_DEFINITION || isValidLocation;
                break;
            case `OBJECT`:
                isValidLocation = node.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || isValidLocation;
                break;
            case `FIELD_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.FIELD_DEFINITION || isValidLocation;
                break;
            case `ARGUMENT_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            case `INTERFACE`:
                isValidLocation = node.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION || isValidLocation;
                break;
            case `UNION`:
                isValidLocation = node.kind === graphql_1.Kind.UNION_TYPE_DEFINITION || isValidLocation;
                break;
            case `ENUM`:
                isValidLocation = node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION || isValidLocation;
                break;
            case `ENUM_VALUE`:
                isValidLocation = node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION || isValidLocation;
                break;
            case `INPUT_OBJECT`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION || isValidLocation;
                break;
            case `INPUT_FIELD_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchDirective = matchDirective;
function matchFieldDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `FIELD_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.FIELD_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchFieldDirective = matchFieldDirective;
function matchInputFieldDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `INPUT_FIELD_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchInputFieldDirective = matchInputFieldDirective;
function matchArgumentDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `ARGUMENT_DEFINITION`:
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchArgumentDirective = matchArgumentDirective;
function matchEnumValueDirective(definition, directive, node) {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case `ENUM_VALUE`:
                isValidLocation = node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
}
exports.matchEnumValueDirective = matchEnumValueDirective;
function sortTransformerPlugins(plugins) {
    const SORT_ORDER = [
        graphql_transformer_interfaces_1.TransformerPluginType.DATA_SOURCE_PROVIDER,
        graphql_transformer_interfaces_1.TransformerPluginType.DATA_SOURCE_ENHANCER,
        graphql_transformer_interfaces_1.TransformerPluginType.GENERIC,
        graphql_transformer_interfaces_1.TransformerPluginType.AUTH,
    ];
    return plugins.sort((a, b) => {
        const aIdx = SORT_ORDER.indexOf(a.pluginType);
        const bIdx = SORT_ORDER.indexOf(b.pluginType);
        return aIdx - bIdx;
    });
}
exports.sortTransformerPlugins = sortTransformerPlugins;
//# sourceMappingURL=utils.js.map