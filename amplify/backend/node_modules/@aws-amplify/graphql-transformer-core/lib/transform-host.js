"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTransformHost = void 0;
const aws_appsync_1 = require("@aws-cdk/aws-appsync");
const aws_lambda_1 = require("@aws-cdk/aws-lambda");
const core_1 = require("@aws-cdk/core");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const object_hash_1 = __importDefault(require("object-hash"));
const appsync_function_1 = require("./appsync-function");
const searchable_datasource_1 = require("./cdk-compat/searchable-datasource");
const template_asset_1 = require("./cdk-compat/template-asset");
class DefaultTransformHost {
    constructor(options) {
        this.dataSources = new Map();
        this.resolvers = new Map();
        this.appsyncFunctions = new Map();
        this.getDataSource = (name) => {
            if (this.hasDataSource(name)) {
                return this.dataSources.get(name);
            }
        };
        this.hasResolver = (typeName, fieldName) => this.resolvers.has(`${typeName}:${fieldName}`);
        this.getResolver = (typeName, fieldName) => {
            if (this.resolvers.has(`${typeName}:${fieldName}`)) {
                return this.resolvers.get(`${typeName}:${fieldName}`);
            }
        };
        this.addHttpDataSource = (name, endpoint, options, stack) => {
            if (this.dataSources.has(name)) {
                throw new Error(`DataSource ${name} already exists in the API`);
            }
            const dataSource = this.doAddHttpDataSource(name, endpoint, options, stack);
            this.dataSources.set(name, dataSource);
            return dataSource;
        };
        this.addDynamoDbDataSource = (name, table, options, stack) => {
            if (this.dataSources.has(name)) {
                throw new Error(`DataSource ${name} already exists in the API`);
            }
            const dataSource = this.doAddDynamoDbDataSource(name, table, options, stack);
            this.dataSources.set((options === null || options === void 0 ? void 0 : options.name) || name, dataSource);
            return dataSource;
        };
        this.addNoneDataSource = (name, options, stack) => {
            if (this.dataSources.has(name)) {
                throw new Error(`DataSource ${name} already exists in the API`);
            }
            const dataSource = this.doAddNoneDataSource(name, options, stack);
            this.dataSources.set(name, dataSource);
            return dataSource;
        };
        this.addLambdaDataSource = (name, lambdaFunction, options, stack) => {
            if (!core_1.Token.isUnresolved(name) && this.dataSources.has(name)) {
                throw new Error(`DataSource ${name} already exists in the API`);
            }
            const dataSource = this.doAddLambdaDataSource(name, lambdaFunction, options, stack);
            this.dataSources.set(name, dataSource);
            return dataSource;
        };
        this.addAppSyncFunction = (name, requestMappingTemplate, responseMappingTemplate, dataSourceName, stack) => {
            if (dataSourceName && !core_1.Token.isUnresolved(dataSourceName) && !this.dataSources.has(dataSourceName)) {
                throw new Error(`DataSource ${dataSourceName} is missing in the API`);
            }
            const dataSource = this.dataSources.get(dataSourceName);
            const obj = {
                dataSource: dataSourceName,
                requestMappingTemplate: requestMappingTemplate.getTemplateHash(),
                responseMappingTemplate: responseMappingTemplate.getTemplateHash(),
            };
            const slotHash = (0, object_hash_1.default)(obj);
            if (this.appsyncFunctions.has(slotHash)) {
                const appsyncFunction = this.appsyncFunctions.get(slotHash);
                requestMappingTemplate.bind(appsyncFunction);
                responseMappingTemplate.bind(appsyncFunction);
                return appsyncFunction;
            }
            const fn = new appsync_function_1.AppSyncFunctionConfiguration(stack || this.api, name, {
                api: this.api,
                dataSource: dataSource || dataSourceName,
                requestMappingTemplate,
                responseMappingTemplate,
            });
            this.appsyncFunctions.set(slotHash, fn);
            return fn;
        };
        this.addResolver = (typeName, fieldName, requestMappingTemplate, responseMappingTemplate, resolverLogicalId, dataSourceName, pipelineConfig, stack) => {
            if (dataSourceName && !core_1.Token.isUnresolved(dataSourceName) && !this.dataSources.has(dataSourceName)) {
                throw new Error(`DataSource ${dataSourceName} is missing in the API`);
            }
            const requestTemplateLocation = requestMappingTemplate.bind(this.api);
            const responseTemplateLocation = responseMappingTemplate.bind(this.api);
            const resolverName = (0, graphql_transformer_common_1.toCamelCase)([(0, graphql_transformer_common_1.resourceName)(typeName), (0, graphql_transformer_common_1.resourceName)(fieldName), 'Resolver']);
            const resourceId = resolverLogicalId !== null && resolverLogicalId !== void 0 ? resolverLogicalId : graphql_transformer_common_1.ResolverResourceIDs.ResolverResourceID(typeName, fieldName);
            if (dataSourceName) {
                const dataSource = this.dataSources.get(dataSourceName);
                const resolver = new aws_appsync_1.CfnResolver(stack || this.api, resolverName, {
                    apiId: this.api.apiId,
                    fieldName,
                    typeName,
                    kind: 'UNIT',
                    dataSourceName: (dataSource === null || dataSource === void 0 ? void 0 : dataSource.ds.attrName) || dataSourceName,
                    ...(requestMappingTemplate instanceof template_asset_1.InlineTemplate
                        ? { requestMappingTemplate: requestTemplateLocation }
                        : { requestMappingTemplateS3Location: requestTemplateLocation }),
                    ...(responseMappingTemplate instanceof template_asset_1.InlineTemplate
                        ? { responseMappingTemplate: responseTemplateLocation }
                        : { responseMappingTemplateS3Location: responseTemplateLocation }),
                });
                resolver.overrideLogicalId(resourceId);
                this.api.addSchemaDependency(resolver);
                return resolver;
            }
            if (pipelineConfig) {
                const resolver = new aws_appsync_1.CfnResolver(stack || this.api, resolverName, {
                    apiId: this.api.apiId,
                    fieldName,
                    typeName,
                    kind: 'PIPELINE',
                    ...(requestMappingTemplate instanceof template_asset_1.InlineTemplate
                        ? { requestMappingTemplate: requestTemplateLocation }
                        : { requestMappingTemplateS3Location: requestTemplateLocation }),
                    ...(responseMappingTemplate instanceof template_asset_1.InlineTemplate
                        ? { responseMappingTemplate: responseTemplateLocation }
                        : { responseMappingTemplateS3Location: responseTemplateLocation }),
                    pipelineConfig: {
                        functions: pipelineConfig,
                    },
                });
                resolver.overrideLogicalId(resourceId);
                this.api.addSchemaDependency(resolver);
                this.resolvers.set(`${typeName}:${fieldName}`, resolver);
                return resolver;
            }
            throw new Error('Resolver needs either dataSourceName or pipelineConfig to be passed');
        };
        this.addLambdaFunction = (functionName, functionKey, handlerName, filePath, runtime, layers, role, environment, timeout, stack) => {
            const dummyCode = 'if __name__ == "__main__":';
            const fn = new aws_lambda_1.Function(stack || this.api, functionName, {
                code: aws_lambda_1.Code.fromInline(dummyCode),
                handler: handlerName,
                runtime,
                role,
                layers,
                environment,
                timeout,
            });
            fn.addLayers();
            const functionCode = new template_asset_1.S3MappingFunctionCode(functionKey, filePath).bind(fn);
            fn.node.defaultChild.code = {
                s3Key: functionCode.s3ObjectKey,
                s3Bucket: functionCode.s3BucketName,
            };
            return fn;
        };
        this.api = options.api;
    }
    setAPI(api) {
        this.api = api;
    }
    hasDataSource(name) {
        return this.dataSources.has(name);
    }
    addSearchableDataSource(name, awsRegion, endpoint, options, stack) {
        if (this.dataSources.has(name)) {
            throw new Error(`DataSource ${name} already exists in the API`);
        }
        const data = this.doAddSearchableDataSource(name, endpoint, awsRegion, options, stack);
        this.dataSources.set((options === null || options === void 0 ? void 0 : options.name) || name, data);
        return data;
    }
    doAddNoneDataSource(id, options, stack) {
        return new aws_appsync_1.NoneDataSource(stack !== null && stack !== void 0 ? stack : this.api, id, {
            api: this.api,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
        });
    }
    doAddDynamoDbDataSource(id, table, options, stack) {
        const ds = new aws_appsync_1.DynamoDbDataSource(stack !== null && stack !== void 0 ? stack : this.api, id, {
            api: this.api,
            table,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
            serviceRole: options === null || options === void 0 ? void 0 : options.serviceRole,
        });
        ds.node.defaultChild.overrideLogicalId(id);
        return ds;
    }
    doAddHttpDataSource(id, endpoint, options, stack) {
        const ds = new aws_appsync_1.HttpDataSource(stack !== null && stack !== void 0 ? stack : this.api, id, {
            api: this.api,
            endpoint,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
            authorizationConfig: options === null || options === void 0 ? void 0 : options.authorizationConfig,
        });
        ds.node.defaultChild.overrideLogicalId(id);
        return ds;
    }
    doAddSearchableDataSource(id, endpoint, region, options, stack) {
        return new searchable_datasource_1.SearchableDataSource(stack !== null && stack !== void 0 ? stack : this.api, id, {
            api: this.api,
            name: options === null || options === void 0 ? void 0 : options.name,
            endpoint,
            region,
            serviceRole: options === null || options === void 0 ? void 0 : options.serviceRole,
        });
    }
    doAddLambdaDataSource(id, lambdaFunction, options, stack) {
        const ds = new aws_appsync_1.LambdaDataSource(stack || this.api, id, {
            api: this.api,
            lambdaFunction,
            name: options === null || options === void 0 ? void 0 : options.name,
            description: options === null || options === void 0 ? void 0 : options.description,
        });
        ds.node.defaultChild.overrideLogicalId(id);
        return ds;
    }
}
exports.DefaultTransformHost = DefaultTransformHost;
//# sourceMappingURL=transform-host.js.map