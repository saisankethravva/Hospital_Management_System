import { ViewResourceTableParams } from './cliViewAPI';
import { ServiceSelection } from './serviceSelection';
import { Tag } from './tags';
export declare type $TSAny = any;
export declare type $TSContext = {
    amplify: AmplifyToolkit;
    print: IContextPrint;
    migrationInfo: $TSAny;
    projectHasMobileHubResources: boolean;
    prompt: $TSAny;
    exeInfo: $TSAny;
    input: $TSAny;
    parameters: $TSAny;
    usageData: $TSAny;
    runtime: $TSAny;
    pluginPlatform: IPluginPlatform;
    newUserInfo?: $TSAny;
    filesystem: IContextFilesystem;
    template: IContextTemplate;
    updatingAuth: $TSAny;
};
export declare type CategoryName = string;
export declare type ResourceName = string;
export declare type IContextPrint = {
    info: (message: string) => void;
    fancy: (message?: string) => void;
    warning: (message: string) => void;
    error: (message: string) => void;
    success: (message: string) => void;
    table: (data: string[][], options?: {
        format?: 'markdown' | 'lean';
    }) => void;
    debug: (message: string) => void;
    green: (message: string) => void;
    yellow: (message: string) => void;
    red: (message: string) => void;
    blue: (message: string) => void;
};
export declare type IContextFilesystem = {
    remove: (targetPath: string) => void;
    read: (targetPath: string, encoding?: string) => $TSAny;
    write: (targetPath: string, data: unknown) => void;
    exists: (targetPath: string) => boolean;
    isFile: (targetPath: string) => boolean;
    path: (...pathParts: string[]) => string;
};
export declare type IContextTemplate = {
    generate: (opts: {
        template: string;
        target: string;
        props: $TSObject;
        directory: string;
    }) => string;
};
export declare type IPluginPlatform = {
    pluginDirectories: string[];
    pluginPrefixes: string[];
    userAddedLocations: string[];
    lastScanTime: Date;
    maxScanIntervalInSeconds: number;
    plugins: IPluginCollection;
    excluded: IPluginCollection;
};
export declare type IPluginCollection = {
    [pluginType: string]: IPluginInfo[];
};
export declare type IPluginInfo = {
    packageName: string;
    packageVersion: string;
    packageLocation: string;
    manifest: $IPluginManifest;
};
export declare type DeploymentSecrets = {
    appSecrets: Array<{
        rootStackId: string;
        environments: {
            [env: string]: {
                [category: string]: {
                    [resourceName: string]: {
                        [key: string]: string;
                    };
                };
            };
        };
    }>;
};
export declare type GetPackageAssetPaths = () => Promise<string[]>;
export declare type $IPluginManifest = $TSAny;
export declare type $TSMeta = $TSAny;
export declare type $TSTeamProviderInfo = $TSAny;
export declare type $TSObject = Record<string, $TSAny>;
export interface ResourceTuple {
    category: string;
    resourceName: string;
}
export declare enum AmplifyFrontend {
    android = "android",
    ios = "ios",
    javascript = "javascript"
}
export interface AmplifyProjectConfig {
    projectName: string;
    version: string;
    frontend: AmplifyFrontend;
    providers: string[];
}
export interface ProviderContext {
    provider: string;
    service: string;
    projectName: string;
}
export declare type $TSCopyJob = $TSAny;
interface AmplifyToolkit {
    confirmPrompt: (prompt: string, defaultValue?: boolean) => Promise<boolean>;
    constants: $TSAny;
    constructExeInfo: (context: $TSContext) => $TSAny;
    copyBatch: (context: $TSContext, jobs: $TSCopyJob[], props: $TSObject, force?: boolean, writeParams?: boolean | $TSObject) => $TSAny;
    crudFlow: (role: string, permissionMap?: $TSObject, defaults?: string[]) => Promise<string[]>;
    deleteProject: (context: $TSContext) => Promise<void>;
    executeProviderUtils: (context: $TSContext, providerName: string, utilName: string, options?: $TSAny) => Promise<$TSAny>;
    getAllEnvs: () => string[];
    getPlugin: () => $TSAny;
    getCategoryPluginInfo: (context: $TSContext, category?: string, service?: string) => $TSAny;
    getAllCategoryPluginInfo: (context: $TSContext) => $TSAny;
    getFrontendPlugins: (context: $TSContext) => $TSAny;
    getEnvDetails: () => $TSAny;
    getEnvInfo: () => $TSAny;
    getProviderPlugins: (context: $TSContext) => Record<string, string>;
    getPluginInstance: (context: $TSContext, pluginName: string) => $TSAny;
    getProjectConfig: () => $TSAny;
    getProjectDetails: () => $TSAny;
    getProjectMeta: () => $TSMeta;
    getResourceStatus: (category?: $TSAny, resourceName?: $TSAny, providerName?: $TSAny, filteredResources?: $TSAny) => $TSAny;
    getResourceOutputs: () => $TSAny;
    getWhen: () => $TSAny;
    inputValidation: (input: $TSAny) => (value: $TSAny) => boolean | string;
    listCategories: () => $TSAny;
    makeId: (n?: number) => string;
    openEditor: (context: $TSContext, target: string, waitToContinue?: boolean) => Promise<void>;
    onCategoryOutputsChange: (context: $TSContext, currentAmplifyMeta: $TSMeta | undefined, amplifyMeta?: $TSMeta) => $TSAny;
    pathManager: $TSAny;
    pressEnterToContinue: () => $TSAny;
    pushResources: (context: $TSContext, category?: string, resourceName?: string, filteredResources?: {
        category: string;
        resourceName: string;
    }[], rebuild?: boolean) => $TSAny;
    storeCurrentCloudBackend: (context: $TSContext) => $TSAny;
    readJsonFile: (fileName: string) => $TSAny;
    removeDeploymentSecrets: (context: $TSContext, category: string, resource: string) => void;
    removeResource: (context: $TSContext, category: string, resource: string, questionOptions?: {
        headless?: boolean;
        serviceSuffix?: {
            [serviceName: string]: string;
        };
        serviceDeletionInfo?: {
            [serviceName: string]: string;
        };
    }, resourceNameCallback?: (resourceName: string) => Promise<void>) => Promise<{
        service: string;
        resourceName: string;
    } | undefined>;
    sharedQuestions: () => $TSAny;
    showAllHelp: () => $TSAny;
    showHelp: (header: string, commands: {
        name: string;
        description: string;
    }[]) => $TSAny;
    showHelpfulProviderLinks: (context: $TSContext) => $TSAny;
    showResourceTable: (category?: $TSAny, resourceName?: $TSAny, filteredResources?: $TSAny) => Promise<$TSAny>;
    showStatusTable: (resourceTableParams: ViewResourceTableParams) => Promise<$TSAny>;
    serviceSelectionPrompt: (context: $TSContext, category: string, servicesMetadata: $TSAny, customQuestion?: $TSAny, optionNameOverrides?: Record<string, string>) => Promise<ServiceSelection>;
    updateProjectConfig: () => $TSAny;
    updateamplifyMetaAfterResourceUpdate: (category: string, resourceName: string, metaResourceKey: string, metaResourceData?: $TSAny) => $TSMeta;
    updateamplifyMetaAfterResourceAdd: (category: string, resourceName: string, metaResourceData: $TSAny, backendResourceData?: $TSAny, overwriteObjectIfExists?: boolean) => void;
    updateamplifyMetaAfterResourceDelete: (category: string, resourceName: string) => void;
    updateProviderAmplifyMeta: (providerName: string, options: $TSObject) => void;
    updateamplifyMetaAfterPush: (resources: $TSObject[]) => Promise<void>;
    updateamplifyMetaAfterBuild: (resource: ResourceTuple, buildType?: string) => void;
    updateAmplifyMetaAfterPackage: (resource: ResourceTuple, zipFilename: string, hash?: {
        resourceKey: string;
        hashValue: string;
    }) => void;
    updateBackendConfigAfterResourceAdd: (category: string, resourceName: string, resourceData: $TSObject) => void;
    updateBackendConfigAfterResourceUpdate: (category: string, resourceName: string, attribute: string, value: $TSAny) => void;
    updateBackendConfigAfterResourceRemove: (category: string, resourceName: string) => void;
    loadEnvResourceParameters: (context: $TSContext, category: string, resourceName: string) => $TSAny;
    saveEnvResourceParameters: (context: $TSContext, category: string, resourceName: string, envSpecificParams?: $TSObject) => void;
    removeResourceParameters: (context: $TSContext, category: string, resource: string) => void;
    triggerFlow: () => $TSAny;
    addTrigger: () => $TSAny;
    updateTrigger: () => $TSAny;
    deleteTrigger: (context: $TSContext, name: string, dir: string) => Promise<void>;
    deleteAllTriggers: (previouslySaved: $TSAny, resourceName: string, targetDir: string, context: $TSContext) => Promise<void>;
    deleteDeselectedTriggers: () => $TSAny;
    dependsOnBlock: (context: $TSContext, dependsOnKeys: string[], service: string) => $TSAny;
    getTriggerMetadata: () => $TSAny;
    getTriggerPermissions: (context: $TSContext, triggers: $TSAny, category: string, resourceName: string) => $TSAny;
    getTriggerEnvVariables: () => $TSAny;
    getTriggerEnvInputs: () => $TSAny;
    getUserPoolGroupList: () => $TSAny[];
    forceRemoveResource: (context: $TSContext, categoryName: string, name: string, dir: string) => $TSAny;
    writeObjectAsJson: () => $TSAny;
    hashDir: (dir: string, exclude: string[]) => Promise<string>;
    leaveBreadcrumbs: (category: string, resourceName: string, breadcrumbs: unknown) => void;
    readBreadcrumbs: (category: string, resourceName: string) => $TSAny;
    loadRuntimePlugin: (context: $TSContext, pluginId: string) => Promise<$TSAny>;
    getImportedAuthProperties: (context: $TSContext) => {
        imported: boolean;
        userPoolId?: string;
        authRoleArn?: string;
        authRoleName?: string;
        unauthRoleArn?: string;
        unauthRoleName?: string;
    };
    invokePluginMethod: <T>(context: $TSContext, category: string, service: string | undefined, method: string, args: $TSAny[]) => Promise<T>;
    getTags: (context: $TSContext) => Tag[];
}
export {};
//# sourceMappingURL=types.d.ts.map